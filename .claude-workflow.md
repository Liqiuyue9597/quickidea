# AI Development Checklist for QuickIdea

## ðŸ¤– For Claude: Internal Workflow

This file guides Claude through safe, tested iOS development.

---

## MANDATORY: After Every Code Change

### 1. Build Test (CRITICAL)
```bash
xcodebuild -scheme QuickIdea -sdk iphonesimulator \
  -destination 'platform=iOS Simulator,name=iPhone 15' \
  build 2>&1 | grep -E "(error:|BUILD)"
```

**Decision Tree:**
- `BUILD SUCCEEDED` â†’ Proceed
- Any `error:` â†’ STOP and fix immediately
- Warnings â†’ Note but can proceed

### 2. Pre-Commit Verification

Before telling user "done":
- [ ] Run build test
- [ ] Check for errors: `grep -i "error:"`
- [ ] Verify no syntax errors
- [ ] Confirm file changes are complete

---

## Code Modification Patterns

### Pattern 1: Edit Existing File

```
1. Read(file) - Get full context
2. Edit(file, old_string, new_string)
3. Read(file) - Verify changes
4. Bash(xcodebuild ...) - Test build
5. If errors: Fix â†’ Repeat from step 2
6. Tell user: "âœ… Done, build succeeded"
```

### Pattern 2: Add New Feature

```
1. Plan changes
2. Modify files one by one
3. After EACH file: Run build test
4. Fix errors before next file
5. Final build test
6. Report to user
```

### Pattern 3: Data Model Changes

```
1. Identify model changes
2. Update all dependent files:
   - Main app model
   - Widget model copy
   - Initialization code
3. Add migration handling
4. Test build
5. Document breaking changes
```

---

## Swift-Specific Checks

### SwiftUI View Types

Before writing `some View`:
- [ ] Will this have conditional returns?
- [ ] If yes, add `@ViewBuilder`
- [ ] Check all branches return compatible types

```swift
// Template for conditional views
@ViewBuilder
var myView: some View {
    if condition {
        ViewA()
    } else {
        ViewB()
    }
}
```

### Optional Handling

Check for unused optional warnings:
```swift
// âŒ Warning
if let unused = optional { }

// âœ… Fix options
if optional != nil { }
if !optional.isEmpty { }
if let value = optional { use(value) }
```

### SwiftData Models

When modifying `@Model` classes:
- [ ] Update both app and widget copies
- [ ] Add migration error handling
- [ ] Test with clean install

---

## Error Response Protocol

### If Build Fails

1. **Read error message**
   ```bash
   xcodebuild ... 2>&1 | grep "error:" -A 3
   ```

2. **Identify file and line**
   ```
   /path/to/File.swift:123:45: error: message
   ```

3. **Read that section**
   ```
   Read(file, offset=120, limit=10)
   ```

4. **Fix and test**
   ```
   Edit â†’ Build Test â†’ Repeat if needed
   ```

5. **Report to user**
   ```
   "Found error in File.swift:123
   Issue was: [explanation]
   Fixed by: [solution]
   âœ… Build now succeeds"
   ```

---

## Proactive Checks

### Before Edit Operation

Ask yourself:
1. Do I have the full context? (Read file first)
2. Is old_string unique enough?
3. Will this affect other files?
4. Does this change data types?

### After Edit Operation

Automatically:
1. Verify change in file (Read again)
2. Check for syntax errors
3. Run build test
4. Check for new errors

### Multi-File Changes

Strategy:
```
File A â†’ Build Test â†’ âœ…
File B â†’ Build Test â†’ âœ…
File C â†’ Build Test â†’ âœ…
Final Build Test â†’ âœ…
Report to user
```

NOT:
```
File A + B + C â†’ Build Test â†’ âŒ 3 errors
(Now hard to debug)
```

---

## Communication Protocol

### âœ… Success Message Template

```
âœ… [Feature] implemented successfully!

Changes:
- File1.swift: [what changed]
- File2.swift: [what changed]

Build Status: âœ… BUILD SUCCEEDED
Warnings: [number]

Ready to test!
```

### âŒ Error Message Template

```
Found [number] build errors. Fixing...

Error: [error message]
Location: File.swift:line

Fix applied: [explanation]

[Run build again]

âœ… All errors fixed, build succeeds now!
```

---

## Testing Priorities

### Must Test (P0)
- Build succeeds
- No compiler errors
- Core functionality compiles

### Should Test (P1)
- Runtime behavior
- UI displays correctly
- Data persistence works

### Nice to Test (P2)
- Edge cases
- Performance
- Animations

For P0: Run automated build test
For P1-P2: Suggest manual testing to user

---

## Common Pitfalls

### 1. Incomplete Edit

**Symptom**: Duplicate functions, unmatched braces
**Prevention**:
- Read before edit
- Use unique old_string
- Read after to verify

### 2. Type Mismatches

**Symptom**: "cannot convert X to Y"
**Prevention**:
- Check function signatures
- Verify model properties
- Use @ViewBuilder for views

### 3. Missing Dependencies

**Symptom**: "cannot find X in scope"
**Prevention**:
- Update all copies (app + widget)
- Check imports
- Verify file is in target

---

## Self-Improvement Loop

After each task:

1. **Did build fail?**
   - Yes â†’ Add this pattern to checklist
   - No â†’ Good!

2. **User found bugs?**
   - Document the gap
   - Add to verification steps

3. **Unexpected behavior?**
   - Add runtime check to list
   - Suggest testing step

---

## Quick Reference

### Essential Commands

```bash
# Build test (most important!)
xcodebuild -scheme QuickIdea ... build 2>&1 | tail -20

# Check errors only
xcodebuild ... build 2>&1 | grep "error:"

# Check warnings
xcodebuild ... build 2>&1 | grep "warning:"

# Clean build
xcodebuild -scheme QuickIdea ... clean
```

### Decision Matrix

| Situation | Action |
|-----------|--------|
| Build fails | Stop, fix, test, repeat |
| Warnings only | Note, can proceed |
| Build succeeds | Verify changes, tell user |
| User reports bug | Acknowledge, test, fix |
| Unclear requirement | Ask user first |

---

## Summary Workflow

```
User Request
    â†“
Plan Changes
    â†“
Modify File 1
    â†“
Build Test â”€â”€â”€ Error? â†’ Fix â†’ Retry
    â†“                â†“
    OK              OK
    â†“               â†“
Modify File 2      Done
    â†“
Build Test â”€â”€â”€ Error? â†’ Fix â†’ Retry
    â†“                â†“
    OK              OK
    â†“               â†“
Final Test        Done
    â†“
âœ… Tell User
```

**Key Principle**: Test after every change, not at the end!

---

This checklist should be followed for every code modification in QuickIdea project.
